"""Payment gateway converters - converts universal schema to gateway-native formats."""

from abc import ABC, abstractmethod
from typing import Dict, Any
from decimal import Decimal

from sdk.server.schemas.schemas import (
    UniversalPaymentRequest,
    GatewayNativeRequest,
    PaymentGateway,
    PaymentMethod
)
from sdk.server.schemas.exceptions import ConversionException, ValidationException


class BaseConverter(ABC):
    """Base class for payment gateway converters."""
    
    def __init__(self, gateway: PaymentGateway):
        self.gateway = gateway
    
    @abstractmethod
    def convert(self, request: UniversalPaymentRequest) -> GatewayNativeRequest:
        """Convert universal schema to gateway-native format."""
        pass
    
    def _validate_request(self, request: UniversalPaymentRequest):
        """Validate universal payment request."""
        if request.amount <= 0:
            raise ValidationException("Amount must be greater than 0")
        
        if request.payment_method in [PaymentMethod.CARD, PaymentMethod.WALLET] and not request.payment_token:
            raise ValidationException("Payment token required for card/wallet payments. Use gateway SDKs to generate tokens.")
        
        if request.payment_method == PaymentMethod.BANK_ACCOUNT and not request.bank_account_details:
            raise ValidationException("Bank account details required for bank account payments")


class StripeConverter(BaseConverter):
    """Converter for Stripe payment gateway."""
    
    def __init__(self):
        super().__init__(PaymentGateway.STRIPE)
    
    def convert(self, request: UniversalPaymentRequest) -> GatewayNativeRequest:
        """
        Convert universal schema to Stripe format.
        
        Uses Stripe payment tokens generated by Stripe Elements (PCI-compliant).
        See: https://stripe.com/docs/payments/accept-a-payment
        """
        self._validate_request(request)
        
        try:
            # Convert amount to cents (Stripe uses smallest currency unit)
            amount_cents = int(request.amount * 100)
            
            payload: Dict[str, Any] = {
                "amount": amount_cents,
                "currency": request.currency.value.lower(),
                "description": request.description or "Payment",
                "metadata": request.metadata or {}
            }
            
            # Add customer information
            if request.customer:
                payload["receipt_email"] = request.customer.email
                if request.customer.name:
                    payload["metadata"]["customer_name"] = request.customer.name
            
            # Add payment source using token from Stripe Elements
            if request.payment_method in [PaymentMethod.CARD, PaymentMethod.WALLET] and request.payment_token:
                # Use the payment token generated by Stripe.js/Elements
                payload["source"] = request.payment_token.token
                
                # Add billing address to payment method (Stripe best practice)
                # Note: When using tokens, billing details are usually set during token creation
                # This is for additional/override billing information if needed
                if request.customer and request.customer.address:
                    payload["billing_details"] = {
                        "address": {
                            "line1": request.customer.address.line1,
                            "line2": request.customer.address.line2,
                            "city": request.customer.address.city,
                            "state": request.customer.address.state,
                            "postal_code": request.customer.address.postal_code,
                            "country": request.customer.address.country
                        }
                    }
                    if request.customer.name:
                        payload["billing_details"]["name"] = request.customer.name
            
            # Add idempotency key if provided
            headers = {}
            if request.idempotency_key:
                headers["Idempotency-Key"] = request.idempotency_key
            
            return GatewayNativeRequest(
                gateway=self.gateway,
                payload=payload,
                headers=headers if headers else None,
                endpoint="/v1/charges"
            )
            
        except Exception as e:
            raise ConversionException(
                f"Failed to convert to Stripe format: {str(e)}",
                self.gateway.value
            )


class PayPalConverter(BaseConverter):
    """Converter for PayPal payment gateway."""
    
    def __init__(self):
        super().__init__(PaymentGateway.PAYPAL)
    
    def convert(self, request: UniversalPaymentRequest) -> GatewayNativeRequest:
        """
        Convert universal schema to PayPal format.
        
        Uses PayPal payment tokens/order IDs generated by PayPal SDK (PCI-compliant).
        See: https://developer.paypal.com/docs/checkout/
        """
        self._validate_request(request)
        
        try:
            payload: Dict[str, Any] = {
                "intent": "CAPTURE",
                "purchase_units": [
                    {
                        "amount": {
                            "currency_code": request.currency.value,
                            "value": str(request.amount)
                        },
                        "description": request.description or "Payment"
                    }
                ]
            }
            
            # Add customer information
            if request.customer:
                payer_info = {
                    "email_address": request.customer.email
                }
                
                if request.customer.name:
                    name_parts = request.customer.name.split(" ", 1)
                    payer_info["name"] = {
                        "given_name": name_parts[0],
                        "surname": name_parts[1] if len(name_parts) > 1 else ""
                    }
                
                if request.customer.address:
                    payer_info["address"] = {
                        "address_line_1": request.customer.address.line1,
                        "address_line_2": request.customer.address.line2,
                        "admin_area_2": request.customer.address.city,
                        "admin_area_1": request.customer.address.state,
                        "postal_code": request.customer.address.postal_code,
                        "country_code": request.customer.address.country
                    }
                
                payload["payer"] = payer_info
            
            # Add payment source using token from PayPal SDK
            if request.payment_method in [PaymentMethod.CARD, PaymentMethod.WALLET] and request.payment_token:
                # Use payment token from PayPal JavaScript SDK
                payload["payment_source"] = {
                    "token": {
                        "id": request.payment_token.token,
                        "type": request.payment_token.token_type.upper()
                    }
                }
            
            # Add request ID for idempotency
            headers = {}
            if request.idempotency_key:
                headers["PayPal-Request-Id"] = request.idempotency_key
            
            return GatewayNativeRequest(
                gateway=self.gateway,
                payload=payload,
                headers=headers if headers else None,
                endpoint="/v2/checkout/orders"
            )
            
        except Exception as e:
            raise ConversionException(
                f"Failed to convert to PayPal format: {str(e)}",
                self.gateway.value
            )


class SquareConverter(BaseConverter):
    """Converter for Square payment gateway."""
    
    def __init__(self):
        super().__init__(PaymentGateway.SQUARE)
    
    def convert(self, request: UniversalPaymentRequest) -> GatewayNativeRequest:
        """
        Convert universal schema to Square format.
        
        Uses Square payment tokens generated by Square Web Payments SDK (PCI-compliant).
        See: https://developer.squareup.com/docs/web-payments/overview
        """
        self._validate_request(request)
        
        try:
            # Convert amount to smallest currency unit
            amount_money = {
                "amount": int(request.amount * 100),
                "currency": request.currency.value
            }
            
            payload: Dict[str, Any] = {
                "amount_money": amount_money,
                "autocomplete": request.autocomplete  # Support delayed capture
            }
            
            # Add payment source using token from Square Web Payments SDK
            if request.payment_method in [PaymentMethod.CARD, PaymentMethod.WALLET]:
                if not request.payment_token:
                    raise ValidationException(
                        "Payment token required for card/wallet payments. "
                        "Generate token using Square Web Payments SDK on the frontend."
                    )
                payload["source_id"] = request.payment_token.token
                
                # Add card verification token if provided (3DS)
                # This is for additional security verification
                if hasattr(request.payment_token, 'verification_token') and request.payment_token.verification_token:
                    payload["verification_token"] = request.payment_token.verification_token
            
            # Add idempotency key (required by Square)
            if request.idempotency_key:
                payload["idempotency_key"] = request.idempotency_key
            else:
                import uuid
                payload["idempotency_key"] = str(uuid.uuid4())
            
            # Add customer information
            if request.customer:
                payload["buyer_email_address"] = request.customer.email
                
                # Add customer_id if available in metadata
                if request.metadata and "customer_id" in request.metadata:
                    payload["customer_id"] = request.metadata["customer_id"]
                
                # Add billing address
                if request.customer.address:
                    payload["billing_address"] = {
                        "address_line_1": request.customer.address.line1,
                        "address_line_2": request.customer.address.line2,
                        "locality": request.customer.address.city,
                        "administrative_district_level_1": request.customer.address.state,
                        "postal_code": request.customer.address.postal_code,
                        "country": request.customer.address.country
                    }
                    
                    # Add shipping address (if different or specified)
                    # Square supports shipping address for fraud prevention
                    if hasattr(request.customer, 'shipping_address') and request.customer.shipping_address:
                        payload["shipping_address"] = {
                            "address_line_1": request.customer.shipping_address.line1,
                            "address_line_2": request.customer.shipping_address.line2,
                            "locality": request.customer.shipping_address.city,
                            "administrative_district_level_1": request.customer.shipping_address.state,
                            "postal_code": request.customer.shipping_address.postal_code,
                            "country": request.customer.shipping_address.country
                        }
            
            # Add note/description
            if request.description:
                payload["note"] = request.description
            
            # Add reference_id for tracking (e.g., order_id)
            if request.metadata and "order_id" in request.metadata:
                payload["reference_id"] = str(request.metadata["order_id"])
            
            # Add statement description suffix (appears on customer's card statement)
            if request.metadata and "statement_description" in request.metadata:
                payload["statement_description_identifier"] = request.metadata["statement_description"]
            
            # Add app fee money if marketplace/platform use case
            if request.metadata and "app_fee_amount" in request.metadata:
                try:
                    app_fee_amount = int(float(request.metadata["app_fee_amount"]) * 100)
                    payload["app_fee_money"] = {
                        "amount": app_fee_amount,
                        "currency": request.currency.value
                    }
                except (ValueError, TypeError):
                    pass  # Skip if invalid format
            
            # Add tip money for restaurant/service use cases
            if request.metadata and "tip_amount" in request.metadata:
                try:
                    tip_amount = int(float(request.metadata["tip_amount"]) * 100)
                    payload["tip_money"] = {
                        "amount": tip_amount,
                        "currency": request.currency.value
                    }
                except (ValueError, TypeError):
                    pass  # Skip if invalid format
            
            return GatewayNativeRequest(
                gateway=self.gateway,
                payload=payload,
                headers=None,
                endpoint="/v2/payments"
            )
            
        except Exception as e:
            raise ConversionException(
                f"Failed to convert to Square format: {str(e)}",
                self.gateway.value
            )


def get_converter(gateway: PaymentGateway) -> BaseConverter:
    """Factory function to get appropriate converter for gateway."""
    converters = {
        PaymentGateway.STRIPE: StripeConverter,
        PaymentGateway.PAYPAL: PayPalConverter,
        PaymentGateway.SQUARE: SquareConverter
    }
    
    converter_class = converters.get(gateway)
    if not converter_class:
        raise ConversionException(
            f"Unsupported gateway: {gateway.value}",
            gateway.value
        )
    
    return converter_class()
