"""Universal payment schemas shared across both APIs."""

from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Optional, Dict, Any
from pydantic import BaseModel, Field, field_validator


class Currency(str, Enum):
    """Supported currencies."""
    USD = "USD"
    EUR = "EUR"
    GBP = "GBP"
    CAD = "CAD"
    AUD = "AUD"


class PaymentMethod(str, Enum):
    """Supported payment methods."""
    CARD = "card"
    BANK_ACCOUNT = "bank_account"
    WALLET = "wallet"


class PaymentStatus(str, Enum):
    """Payment status enum."""
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"
    REFUNDED = "refunded"
    PARTIALLY_REFUNDED = "partially_refunded"
    AUTHORIZED = "authorized"  # For delayed capture


class PaymentGateway(str, Enum):
    """Supported payment gateways."""
    STRIPE = "stripe"
    PAYPAL = "paypal"
    SQUARE = "square"


class Address(BaseModel):
    """Address information."""
    line1: str
    line2: Optional[str] = None
    city: str
    state: Optional[str] = None
    postal_code: str
    country: str


class PaymentToken(BaseModel):
    """
    Payment token generated by gateway-specific SDK (PCI-compliant).
    
    Instead of collecting raw card data, use:
    - Stripe Elements to generate payment tokens
    - PayPal SDK to generate order IDs
    - Square Web Payments SDK to generate payment tokens
    
    This approach ensures PCI DSS compliance by never handling raw card data.
    """
    token: str = Field(..., description="Payment token/source ID from gateway SDK")
    token_type: str = Field(default="card", description="Token type (card, bank_account, wallet)")
    last4: Optional[str] = Field(None, description="Last 4 digits of card (for display)")
    brand: Optional[str] = Field(None, description="Card brand (visa, mastercard, etc.)")
    exp_month: Optional[int] = Field(None, ge=1, le=12, description="Expiration month (for display)")
    exp_year: Optional[int] = Field(None, description="Expiration year (for display)")


class BankAccountDetails(BaseModel):
    """Bank account details."""
    account_number: str
    routing_number: str
    account_holder_name: str
    account_type: Optional[str] = "checking"


class Customer(BaseModel):
    """Customer information."""
    id: Optional[str] = None
    email: str
    name: str
    phone: Optional[str] = None
    address: Optional[Address] = None


class UniversalPaymentRequest(BaseModel):
    """
    Universal payment request schema (PCI DSS compliant).
    
    IMPORTANT: This system uses payment tokens from official gateway SDKs
    to maintain PCI DSS compliance. Never send raw card data to the API.
    
    Frontend integration:
    1. Use Stripe Elements, PayPal SDK, or Square Web Payments SDK
    2. Generate a payment token on the client side
    3. Send the token to this API
    """
    amount: Decimal = Field(..., gt=0, description="Payment amount")
    currency: Currency = Field(default=Currency.USD)
    payment_method: PaymentMethod
    customer: Customer
    payment_token: Optional[PaymentToken] = None
    bank_account_details: Optional[BankAccountDetails] = None
    description: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict)
    idempotency_key: Optional[str] = None
    autocomplete: bool = Field(default=True, description="If False, only authorize payment (delayed capture)")
    
    # Optional gateway API keys (allows users to use their own accounts)
    gateway_keys: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Optional gateway API keys. Format: {'stripe': 'sk_...', 'square': 'sq0atp...', 'paypal': {'clientId': '...', 'secret': '...'}}"
    )

    @field_validator('payment_token')
    @classmethod
    def validate_payment_token(cls, v, info):
        """Validate payment token is provided when payment method is card or wallet."""
        payment_method = info.data.get('payment_method')
        if payment_method in [PaymentMethod.CARD, PaymentMethod.WALLET] and v is None:
            raise ValueError('payment_token required for card/wallet payment methods')
        return v

    @field_validator('bank_account_details')
    @classmethod
    def validate_bank_account_details(cls, v, info):
        """Validate bank account details are provided when payment method is bank_account."""
        if info.data.get('payment_method') == PaymentMethod.BANK_ACCOUNT and v is None:
            raise ValueError('bank_account_details required for bank_account payment method')
        return v

class UniversalPaymentResponse(BaseModel):
    """Universal payment response schema."""
    transaction_id: str
    gateway: PaymentGateway
    status: PaymentStatus
    amount: Decimal
    currency: Currency
    gateway_transaction_id: Optional[str] = None
    fee: Optional[Decimal] = None
    savings: Optional[Decimal] = None
    created_at: datetime
    updated_at: Optional[datetime] = None
    metadata: Optional[Dict[str, Any]] = None
    error_message: Optional[str] = None
    error_code: Optional[str] = None


class GatewayNativeRequest(BaseModel):
    """Gateway-native formatted request."""
    gateway: PaymentGateway
    payload: Dict[str, Any]
    headers: Optional[Dict[str, str]] = None
    endpoint: str


class GatewayNativeResponse(BaseModel):
    """Gateway-native response."""
    gateway: PaymentGateway
    raw_response: Dict[str, Any]
    status_code: int
    headers: Optional[Dict[str, str]] = None


class RefundRequest(BaseModel):
    """Request to refund a payment."""
    transaction_id: str = Field(..., description="Original transaction ID")
    amount: Optional[Decimal] = Field(None, gt=0, description="Amount to refund (omit for full refund)")
    reason: Optional[str] = Field(None, description="Reason for refund")
    idempotency_key: Optional[str] = None


class RefundResponse(BaseModel):
    """Response from refund operation."""
    refund_id: str
    transaction_id: str
    gateway: PaymentGateway
    status: PaymentStatus
    amount: Decimal
    currency: Currency
    gateway_refund_id: Optional[str] = None
    created_at: datetime
    reason: Optional[str] = None


class CaptureRequest(BaseModel):
    """Request to capture an authorized payment."""
    transaction_id: str = Field(..., description="Original authorization transaction ID")
    amount: Optional[Decimal] = Field(None, gt=0, description="Amount to capture (omit for full amount)")


class CaptureResponse(BaseModel):
    """Response from capture operation."""
    capture_id: str
    transaction_id: str
    gateway: PaymentGateway
    status: PaymentStatus
    amount: Decimal
    currency: Currency
    gateway_capture_id: Optional[str] = None
    created_at: datetime


class RecurringPaymentSchedule(BaseModel):
    """Recurring payment schedule configuration."""
    frequency: str = Field(..., description="Frequency: daily, weekly, monthly, yearly")
    interval: int = Field(1, ge=1, description="Interval between payments")
    start_date: datetime = Field(..., description="First payment date")
    end_date: Optional[datetime] = Field(None, description="Last payment date (omit for indefinite)")
    max_payments: Optional[int] = Field(None, ge=1, description="Maximum number of payments")


class RecurringPaymentRequest(BaseModel):
    """Request to set up recurring payments."""
    payment_request: UniversalPaymentRequest
    schedule: RecurringPaymentSchedule
    subscription_name: str = Field(..., description="Name/description of subscription")


class RecurringPaymentResponse(BaseModel):
    """Response from recurring payment setup."""
    subscription_id: str
    gateway: PaymentGateway
    status: str
    schedule: RecurringPaymentSchedule
    next_payment_date: datetime
    created_at: datetime


class WebhookEvent(BaseModel):
    """Webhook event from payment gateway."""
    event_id: str
    gateway: PaymentGateway
    event_type: str
    transaction_id: Optional[str] = None
    payload: Dict[str, Any]
    created_at: datetime
    verified: bool = False
